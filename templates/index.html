<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assaultron Interface</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .resize-handle {
            background: #e5e5e5;
            cursor: ew-resize;
            width: 4px;
            min-height: 100%;
        }
        .resize-handle:hover {
            background: #999;
        }
        .panel {
            min-width: 300px;
        }
    </style>
</head>
<body class="bg-white text-gray-900 min-h-screen font-mono">
    <div class="h-screen flex flex-col">
        <!-- Tab Navigation -->
        <div class="bg-gray-100 border-b border-gray-300">
            <nav class="flex space-x-4 px-3">
                <button onclick="switchTab('interface')" id="tabInterface" class="tab-button active py-2 px-4 text-sm font-bold border-b-2 border-blue-500">INTERFACE</button>
                <button onclick="switchTab('embodied')" id="tabEmbodied" class="tab-button py-2 px-4 text-sm font-bold border-b-2 border-transparent hover:border-gray-400">EMBODIED AGENT</button>
            </nav>
        </div>
        
        <!-- Interface Tab Content -->
        <div id="interfaceTab" class="flex-1 flex tab-content">
            <!-- Logs Panel -->
            <div id="logsPanel" class="panel bg-gray-50 border-r border-gray-300 flex flex-col" style="width: 50%;">
                <div class="p-3 bg-gray-100 border-b border-gray-300">
                    <h2 class="text-sm font-bold">System Logs</h2>
                </div>
                <div id="systemLogs" class="flex-1 p-3 overflow-y-auto text-xs space-y-1 bg-white">
                    <div class="text-blue-600">[INFO] Interface initialized</div>
                </div>
            </div>
            
            <!-- Resize Handle -->
            <div class="resize-handle" id="resizeHandle"></div>
            
            <!-- Chat Panel -->
            <div id="chatPanel" class="panel flex-1 flex flex-col">
                <div class="p-3 bg-gray-100 border-b border-gray-300">
                    <h2 class="text-sm font-bold">Chat</h2>
                </div>
                <div id="chatHistory" class="flex-1 p-3 overflow-y-auto text-sm space-y-2 bg-white">
                    <div class="text-green-600 font-bold">ASSAULTRON UNIT ASR-7 ONLINE - AWAITING OPERATOR COMMANDS</div>
                </div>
                <div class="p-3 border-t border-gray-300 bg-gray-50">
                    <div class="flex gap-2">
                        <input 
                            type="text" 
                            id="chatInput" 
                            placeholder="ENTER COMMAND OR COMMUNICATION..."
                            class="flex-1 px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:border-blue-500"
                        >
                        <button 
                            id="sendBtn"
                            class="px-4 py-2 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:bg-gray-400"
                        >
                            TRANSMIT
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Embodied Agent Tab Content -->
        <div id="embodiedTab" class="flex-1 flex flex-col tab-content hidden p-4 overflow-y-auto">
            <h2 class="text-lg font-bold mb-4 text-purple-600">EMBODIED AGENT SYSTEM</h2>

            <div class="grid grid-cols-3 gap-4">
                <!-- Cognitive State -->
                <div class="p-4 border border-purple-300 rounded bg-purple-50">
                    <h3 class="font-bold text-sm mb-3 text-purple-700">COGNITIVE LAYER</h3>
                    <div id="cognitiveState" class="text-xs space-y-2">
                        <div><span class="font-bold">Goal:</span> <span id="cogGoal" class="text-purple-600">idle</span></div>
                        <div><span class="font-bold">Emotion:</span> <span id="cogEmotion" class="text-purple-600">neutral</span></div>
                        <div><span class="font-bold">Confidence:</span> <span id="cogConfidence" class="text-purple-600">0.0</span></div>
                        <div><span class="font-bold">Urgency:</span> <span id="cogUrgency" class="text-purple-600">0.0</span></div>
                        <div><span class="font-bold">Focus:</span> <span id="cogFocus" class="text-purple-600">null</span></div>
                    </div>
                </div>

                <!-- Virtual Body State - Enhanced for Assaultron -->
                <div class="p-4 border border-blue-300 rounded bg-blue-50">
                    <h3 class="font-bold text-sm mb-3 text-blue-700">VIRTUAL BODY (ASSAULTRON)</h3>
                    <div id="bodyState" class="text-xs space-y-2">
                        <div class="font-bold text-xs mb-1 text-blue-800">HEAD UNIT</div>
                        <div><span class="font-bold">Head Tilt:</span> <span id="bodyHeadTilt" class="text-blue-600">0Â°</span></div>
                        <div><span class="font-bold">Head Pan:</span> <span id="bodyHeadPan" class="text-blue-600">0Â°</span></div>
                        <div><span class="font-bold">Eye Luminance:</span> <span id="bodyLuminance" class="text-blue-600">dim</span></div>

                        <div class="font-bold text-xs mb-1 mt-2 text-blue-800">TORSO</div>
                        <div><span class="font-bold">Posture:</span> <span id="bodyPosture" class="text-blue-600">idle</span></div>
                        <div><span class="font-bold">Torso Rotation:</span> <span id="bodyTorsoRotation" class="text-blue-600">0Â°</span></div>
                        <div><span class="font-bold">Lean Angle:</span> <span id="bodyLeanAngle" class="text-blue-600">0Â°</span></div>

                        <div class="font-bold text-xs mb-1 mt-2 text-blue-800">ARMS</div>
                        <div><span class="font-bold">Left Hand:</span> <span id="bodyLeftHand" class="text-blue-600">closed</span></div>
                        <div><span class="font-bold">Right Hand:</span> <span id="bodyRightHand" class="text-blue-600">closed</span></div>
                        <div><span class="font-bold">Arm Mode:</span> <span id="bodyArmMode" class="text-blue-600">neutral</span></div>

                        <div class="font-bold text-xs mb-1 mt-2 text-blue-800">LOCOMOTION</div>
                        <div><span class="font-bold">Leg Stance:</span> <span id="bodyLegStance" class="text-blue-600">stable</span></div>
                        <div><span class="font-bold">Balance:</span> <span id="bodyBalance" class="text-blue-600">100%</span></div>
                        <div><span class="font-bold">Movement:</span> <span id="bodyMovement" class="text-blue-600">stationary</span></div>

                        <div class="font-bold text-xs mb-1 mt-2 text-blue-800">SENSORS</div>
                        <div><span class="font-bold">Attention:</span> <span id="bodyAttention" class="text-blue-600">null</span></div>
                    </div>
                </div>

                <!-- World State -->
                <div class="p-4 border border-green-300 rounded bg-green-50">
                    <h3 class="font-bold text-sm mb-3 text-green-700">WORLD PERCEPTION</h3>
                    <div id="worldState" class="text-xs space-y-2">
                        <div><span class="font-bold">Environment:</span> <span id="worldEnv" class="text-green-600">normal</span></div>
                        <div><span class="font-bold">Threat Level:</span> <span id="worldThreat" class="text-green-600">none</span></div>
                        <div><span class="font-bold">Entities:</span> <span id="worldEntities" class="text-green-600">none</span></div>
                        <div><span class="font-bold">Time of Day:</span> <span id="worldTime" class="text-green-600">unknown</span></div>
                    </div>
                </div>
            </div>

            <!-- Motion Controller Hardware State -->
            <div class="mt-4 grid grid-cols-2 gap-4">
                <div class="p-4 border border-orange-300 rounded bg-orange-50">
                    <h3 class="font-bold text-sm mb-3 text-orange-700">MOTION CONTROLLER OUTPUT</h3>
                    <div id="motionState" class="text-xs space-y-2">
                        <div><span class="font-bold">LED Intensity:</span> <span id="motionLED" class="text-orange-600">0%</span></div>
                        <div><span class="font-bold">Left Hand Pos:</span> <span id="motionLeftPos" class="text-orange-600">0</span></div>
                        <div><span class="font-bold">Right Hand Pos:</span> <span id="motionRightPos" class="text-orange-600">0</span></div>
                        <div><span class="font-bold">Hand Mode:</span> <span id="motionHandMode" class="text-orange-600">idle</span></div>
                    </div>
                </div>

                <!-- Voice System -->
                <div class="p-4 border border-red-300 rounded bg-red-50">
                    <h3 class="font-bold text-sm mb-3 text-red-700">VOICE SYSTEM</h3>
                    <div class="space-y-3">
                        <div class="flex items-center gap-2">
                            <button id="voiceStartBtn" onclick="startVoiceServer()"
                                    class="px-3 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600 disabled:bg-gray-400">
                                START
                            </button>
                            <button id="voiceStopBtn" onclick="stopVoiceServer()"
                                    class="px-3 py-1 bg-gray-500 text-white rounded text-xs hover:bg-gray-600 disabled:bg-gray-400" disabled>
                                STOP
                            </button>
                            <div class="flex items-center gap-2">
                                <span id="voiceStatusText" class="text-xs text-red-500">Offline</span>
                                <div id="voiceStatusIndicator" class="w-2 h-2 rounded-full bg-red-500"></div>
                            </div>
                        </div>
                        <div id="voiceDetails" class="text-xs text-gray-600">
                            Server: <span id="serverStatus">Stopped</span> |
                            Model: <span id="modelStatus">Not loaded</span>
                        </div>
                        <div class="flex gap-2">
                            <input type="text" id="testSpeechInput" placeholder="Test speech..."
                                   class="flex-1 px-2 py-1 border border-gray-300 rounded text-xs">
                            <button onclick="testSpeech()"
                                    class="px-3 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600 disabled:bg-gray-400">
                                TEST
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Behavior Selection History -->
            <div class="mt-4 p-4 border border-indigo-300 rounded bg-indigo-50">
                <h3 class="font-bold text-sm mb-3 text-indigo-700">BEHAVIOR SELECTION HISTORY</h3>
                <div id="behaviorHistory" class="text-xs space-y-1 max-h-64 overflow-y-auto">
                    <div class="text-gray-500">No behaviors executed yet</div>
                </div>
            </div>

            <!-- State Transition History -->
            <div class="mt-4 p-4 border border-teal-300 rounded bg-teal-50">
                <h3 class="font-bold text-sm mb-3 text-teal-700">STATE TRANSITION HISTORY</h3>
                <div id="stateHistory" class="text-xs space-y-1 max-h-64 overflow-y-auto">
                    <div class="text-gray-500">No state changes yet</div>
                </div>
            </div>
        </div>

        
        <!-- Bottom Stats Section -->
        <div class="border-t border-gray-300 bg-gray-50 p-3">
            <div class="grid grid-cols-6 gap-4 text-xs">
                <div class="text-center">
                    <div class="text-gray-500">API Status</div>
                    <div id="apiStatus" class="font-bold text-red-500">Offline</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Response Time</div>
                    <div id="responseTime" class="font-bold">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Ping</div>
                    <div id="ping" class="font-bold">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Messages</div>
                    <div id="messageCount" class="font-bold">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Model</div>
                    <div id="modelName" class="font-bold">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Uptime</div>
                    <div id="uptime" class="font-bold">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let messageCount = 0;
        let startTime = Date.now();
        let lastPingTime = 0;
        let currentTab = 'interface';

        // DOM elements
        const logsPanel = document.getElementById('logsPanel');
        const chatPanel = document.getElementById('chatPanel');
        const resizeHandle = document.getElementById('resizeHandle');
        const systemLogs = document.getElementById('systemLogs');
        const chatHistory = document.getElementById('chatHistory');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');

        // Stats elements
        const apiStatus = document.getElementById('apiStatus');
        const responseTimeEl = document.getElementById('responseTime');
        const pingEl = document.getElementById('ping');
        const messageCountEl = document.getElementById('messageCount');
        const modelNameEl = document.getElementById('modelName');
        const uptimeEl = document.getElementById('uptime');

        // Panel resizing
        let isResizing = false;

        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        });

        function handleResize(e) {
            if (!isResizing) return;
            
            const containerWidth = window.innerWidth;
            const newWidth = (e.clientX / containerWidth) * 100;
            
            if (newWidth > 20 && newWidth < 80) {
                logsPanel.style.width = `${newWidth}%`;
            }
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', handleResize);
            document.removeEventListener('mouseup', stopResize);
        }

        // Logging
        function addLog(level, message) {
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                INFO: 'text-blue-600',
                WARN: 'text-yellow-600',
                WARNING: 'text-orange-600',
                ERROR: 'text-red-600',
                AI: 'text-green-600',
                COGNITIVE: 'text-purple-600',
                BEHAVIOR: 'text-indigo-600',
                MOTION: 'text-orange-600',
                WORLD: 'text-green-600',
                CONTEXT: 'text-purple-600',
                ACTION: 'text-indigo-600',
                TOOL: 'text-teal-600',
                VOICE: 'text-pink-600',
                MANUAL: 'text-gray-600',
                MEMORY: 'text-purple-400'
            };
            
            const logDiv = document.createElement('div');
            logDiv.className = colors[level] || 'text-gray-600';
            logDiv.textContent = `[${timestamp}] [${level}] ${message}`;
            
            systemLogs.appendChild(logDiv);
            systemLogs.scrollTop = systemLogs.scrollHeight;
            
            // Keep only last 100 logs
            while (systemLogs.children.length > 100) {
                systemLogs.removeChild(systemLogs.firstChild);
            }
        }

        // Chat functions
        function addChatMessage(sender, message) {
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            
            if (sender === 'USER') {
                div.innerHTML = `<div class="text-right"><span class="text-gray-500">[${timestamp}]</span> <span class="text-blue-600 font-bold">OPERATOR:</span> ${message}</div>`;
            } else if (sender === 'ASSAULTRON') {
                div.innerHTML = `<div><span class="text-gray-500">[${timestamp}]</span> <span class="text-green-600 font-bold">ASR-7:</span> ${message}</div>`;
            } else {
                div.innerHTML = `<div><span class="text-gray-500">[${timestamp}]</span> <span class="text-gray-600 font-bold">${sender}:</span> ${message}</div>`;
            }
            
            chatHistory.appendChild(div);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        // API functions
        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            addChatMessage('USER', message);
            chatInput.value = '';
            sendBtn.disabled = true;
            sendBtn.textContent = 'TRANSMITTING';
            
            const startTime = performance.now();
            
            try {
                addLog('AI', `Sending: ${message.substring(0, 50)}...`);
                
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                if (response.ok) {
                    const data = await response.json();
                    addChatMessage('ASSAULTRON', data.response);
                    messageCount++;
                    messageCountEl.textContent = messageCount;
                    responseTimeEl.textContent = `${responseTime}ms`;
                    addLog('AI', `Response received (${responseTime}ms)`);

                    // Log cognitive state if available
                    if (data.cognitive_state) {
                        addLog('COGNITIVE', `Goal: ${data.cognitive_state.goal}, Emotion: ${data.cognitive_state.emotion}`);
                    }

                    // Update embodied agent display if on that tab
                    if (currentTab === 'embodied') {
                        updateEmbodiedAgentData();
                    }
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
                
            } catch (error) {
                addChatMessage('SYSTEM', `Error: ${error.message}`);
                addLog('ERROR', `Chat failed: ${error.message}`);
                responseTimeEl.textContent = 'Error';
            }

            sendBtn.disabled = false;
            sendBtn.textContent = 'TRANSMIT';
        }

        async function updateStats() {
            const pingStart = performance.now();
            
            try {
                const response = await fetch('/api/status');
                const pingEnd = performance.now();
                const ping = Math.round(pingEnd - pingStart);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update status indicators
                    if (data.ai_active) {
                        apiStatus.textContent = 'Online';
                        apiStatus.className = 'font-bold text-green-500';
                    } else {
                        apiStatus.textContent = 'Offline';
                        apiStatus.className = 'font-bold text-red-500';
                    }
                    
                    pingEl.textContent = `${ping}ms`;
                    pingEl.className = ping < 100 ? 'font-bold text-green-500' : 
                                      ping < 500 ? 'font-bold text-yellow-500' : 'font-bold text-red-500';
                    
                    // Update other stats
                    messageCountEl.textContent = data.conversation_count || messageCount;
                    
                } else {
                    throw new Error('Status check failed');
                }
                
            } catch (error) {
                apiStatus.textContent = 'Error';
                apiStatus.className = 'font-bold text-red-500';
                pingEl.textContent = 'Error';
                addLog('ERROR', `Stats update failed: ${error.message}`);
            }
        }

        async function getModelInfo() {
            try {
                const response = await fetch('http://localhost:11434/api/tags');
                if (response.ok) {
                    const data = await response.json();
                    if (data.models && data.models.length > 0) {
                        modelNameEl.textContent = data.models[0].name;
                    }
                }
            } catch (error) {
                modelNameEl.textContent = 'Unknown';
            }
        }

        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const seconds = Math.floor(elapsed / 1000) % 60;
            const minutes = Math.floor(elapsed / 60000) % 60;
            const hours = Math.floor(elapsed / 3600000);
            
            uptimeEl.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Event listeners
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        
        // Voice system event listeners
        document.getElementById('testSpeechInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') testSpeech();
        });

        // Tab Management
        function switchTab(tabName) {
            currentTab = tabName;

            // Hide all tabs
            document.getElementById('interfaceTab').classList.toggle('hidden', tabName !== 'interface');
            document.getElementById('embodiedTab').classList.toggle('hidden', tabName !== 'embodied');

            // Update tab buttons
            const tabs = ['Interface', 'Embodied'];
            tabs.forEach(tab => {
                const tabEl = document.getElementById(`tab${tab}`);
                const isActive = tabName === tab.toLowerCase();
                tabEl.classList.toggle('active', isActive);
                tabEl.classList.toggle('border-blue-500', isActive);
                tabEl.classList.toggle('border-transparent', !isActive);
            });

            if (tabName === 'embodied') {
                updateEmbodiedAgentData();
            }
        }


        // Voice System Functions
        async function startVoiceServer() {
            const startBtn = document.getElementById('voiceStartBtn');
            const stopBtn = document.getElementById('voiceStopBtn');

            try {
                startBtn.disabled = true;
                startBtn.textContent = 'STARTING...';

                addLog('VOICE', 'Starting Assaultron voice system...');
                updateVoiceStatus(false, 'Starting...', 'Starting', 'Loading');

                const response = await fetch('/api/voice/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                if (data.success) {
                    addLog('VOICE', 'Voice system started successfully!');
                    updateVoiceStatus(true, 'Online', 'Running', 'Loaded');

                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    startBtn.textContent = 'ONLINE';
                } else {
                    throw new Error(data.error || 'Failed to start voice system');
                }

            } catch (error) {
                addLog('ERROR', `Voice system startup failed: ${error.message}`);
                updateVoiceStatus(false, 'Offline', 'Stopped', 'Not loaded');

                startBtn.disabled = false;
                startBtn.textContent = 'START';
            }
        }

        async function stopVoiceServer() {
            const startBtn = document.getElementById('voiceStartBtn');
            const stopBtn = document.getElementById('voiceStopBtn');

            try {
                stopBtn.disabled = true;
                stopBtn.textContent = 'STOPPING...';

                addLog('VOICE', 'Stopping voice system...');

                const response = await fetch('/api/voice/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                if (data.success) {
                    addLog('VOICE', 'Voice system stopped');
                    updateVoiceStatus(false, 'Offline', 'Stopped', 'Not loaded');

                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    startBtn.textContent = 'START';
                    stopBtn.textContent = 'STOP';
                } else {
                    throw new Error(data.error || 'Failed to stop voice system');
                }
                
            } catch (error) {
                addLog('ERROR', `Voice system stop failed: ${error.message}`);
                stopBtn.disabled = false;
                stopBtn.textContent = 'STOP';
            }
        }

        function updateVoiceStatus(enabled, statusText, serverStatus, modelStatus) {
            const statusTextEl = document.getElementById('voiceStatusText');
            const statusIndicator = document.getElementById('voiceStatusIndicator');
            const serverStatusEl = document.getElementById('serverStatus');
            const modelStatusEl = document.getElementById('modelStatus');
            
            // Update main status
            statusTextEl.textContent = statusText;
            statusTextEl.className = enabled ? 'text-green-500' : 'text-red-500';
            
            // Update status indicator
            statusIndicator.className = enabled ? 
                'w-2 h-2 rounded-full bg-green-500 animate-pulse' : 
                'w-2 h-2 rounded-full bg-red-500';
            
            // Update detailed status
            serverStatusEl.textContent = serverStatus;
            modelStatusEl.textContent = modelStatus;
        }

        async function testSpeechInternal(text) {
            try {
                addLog('VOICE', `Testing speech: "${text}"`);
                
                const response = await fetch('/api/voice/speak', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addLog('VOICE', 'Speech synthesis started');
                    return true;
                } else {
                    throw new Error(data.error || 'Speech synthesis failed');
                }
                
            } catch (error) {
                addLog('ERROR', `Speech test failed: ${error.message}`);
                return false;
            }
        }

        async function testSpeech() {
            const testInput = document.getElementById('testSpeechInput');
            const text = testInput.value.trim();
            
            if (!text) {
                addLog('WARNING', 'No test text provided');
                return;
            }
            
            const success = await testSpeechInternal(text);
            if (success) {
                testInput.value = ''; // Clear input on success
            }
        }

        async function updateVoiceSystemStatus() {
            try {
                const response = await fetch('/api/voice/status');
                if (response.ok) {
                    const status = await response.json();
                    
                    const enabled = status.voice_enabled && status.initialized && status.server_running;
                    const statusText = enabled ? 
                        `Voice system online (${status.model_info?.name || 'Unknown Model'})` :
                        'Voice system offline';
                    
                    const serverStatus = status.server_running ? 'Running' : 'Stopped';
                    const modelStatus = status.model_loaded ? 
                        (status.model_info?.name ? `${status.model_info.name} (${status.model_info.type})` : 'Loaded') :
                        'Not loaded';
                    
                    updateVoiceStatus(enabled, statusText, serverStatus, modelStatus);
                    
                    // Update button states
                    const startBtn = document.getElementById('voiceStartBtn');
                    const stopBtn = document.getElementById('voiceStopBtn');
                    
                    if (enabled) {
                        startBtn.disabled = true;
                        startBtn.textContent = 'âœ… VOICE ONLINE';
                        stopBtn.disabled = false;
                    } else {
                        startBtn.disabled = false;
                        startBtn.textContent = 'ðŸš€ START VOICE SERVER';
                        stopBtn.disabled = true;
                    }
                }
            } catch (error) {
                // Silently fail for status updates to avoid spam
                console.log('Voice status update failed:', error.message);
            }
        }

        // Embodied Agent Functions
        async function updateEmbodiedAgentData() {
            await Promise.all([
                updateVirtualWorld(),
                updateBehaviorHistory(),
                updateStateHistory()
            ]);
        }

        async function updateVirtualWorld() {
            try {
                const response = await fetch('/api/embodied/virtual_world');
                if (response.ok) {
                    const data = await response.json();

                    // Update cognitive state
                    if (data.cognitive_state) {
                        document.getElementById('cogGoal').textContent = data.cognitive_state.goal || 'idle';
                        document.getElementById('cogEmotion').textContent = data.cognitive_state.emotion || 'neutral';
                        document.getElementById('cogConfidence').textContent = (data.cognitive_state.confidence || 0).toFixed(2);
                        document.getElementById('cogUrgency').textContent = (data.cognitive_state.urgency || 0).toFixed(2);
                        document.getElementById('cogFocus').textContent = data.cognitive_state.focus || 'null';
                    }

                    // Update body state
                    if (data.body_state) {
                        document.getElementById('bodyPosture').textContent = data.body_state.posture || 'idle';
                        document.getElementById('bodyLuminance').textContent = data.body_state.luminance || 'dim';
                        document.getElementById('bodyLeftHand').textContent = data.body_state.left_hand || 'closed';
                        document.getElementById('bodyRightHand').textContent = data.body_state.right_hand || 'closed';
                        document.getElementById('bodyAttention').textContent = data.body_state.attention_focus || 'null';
                    }

                    // Update world state
                    if (data.world_state) {
                        document.getElementById('worldEnv').textContent = data.world_state.environment || 'normal';
                        document.getElementById('worldThreat').textContent = data.world_state.threat_level || 'none';
                        document.getElementById('worldEntities').textContent =
                            (data.world_state.entities && data.world_state.entities.length > 0) ?
                            data.world_state.entities.join(', ') : 'none';
                        document.getElementById('worldTime').textContent = data.world_state.time_of_day || 'unknown';
                    }

                    // Update motion/hardware state (from last hardware state)
                    const hwResponse = await fetch('/api/hardware');
                    if (hwResponse.ok) {
                        const hwData = await hwResponse.json();
                        document.getElementById('motionLED').textContent = `${hwData.led_intensity}%`;
                        document.getElementById('motionLeftPos').textContent = hwData.hands.left.position;
                        document.getElementById('motionRightPos').textContent = hwData.hands.right.position;
                        document.getElementById('motionHandMode').textContent = hwData.hands.mode || 'idle';
                    }
                }
            } catch (error) {
                addLog('ERROR', `Failed to update embodied agent data: ${error.message}`);
            }
        }

        async function updateBehaviorHistory() {
            try {
                const response = await fetch('/api/embodied/behavior_history');
                if (response.ok) {
                    const data = await response.json();
                    const behaviorDiv = document.getElementById('behaviorHistory');

                    if (data.length === 0) {
                        behaviorDiv.innerHTML = '<div class="text-gray-500">No behaviors executed yet</div>';
                    } else {
                        behaviorDiv.innerHTML = data.map(entry => {
                            const timestamp = new Date(entry.timestamp).toLocaleTimeString();
                            const alternatives = entry.all_utilities ? entry.all_utilities.map(([name, utility]) =>
                                `${name}: ${utility.toFixed(2)}`
                            ).join(', ') : 'N/A';
                            return `<div class="border-b border-indigo-200 pb-1 mb-1">
                                <div class="font-bold text-indigo-600">[${timestamp}] ${entry.selected_behavior} (utility: ${entry.selected_utility.toFixed(2)})</div>
                                <div class="text-gray-600">Goal: ${entry.cognitive_state.goal}, Emotion: ${entry.cognitive_state.emotion}</div>
                                <div class="text-gray-500 text-xs">Alternatives: ${alternatives}</div>
                            </div>`;
                        }).join('');
                    }
                }
            } catch (error) {
                addLog('ERROR', `Failed to update behavior history: ${error.message}`);
            }
        }

        async function updateStateHistory() {
            try {
                const response = await fetch('/api/embodied/state_history');
                if (response.ok) {
                    const data = await response.json();
                    const stateDiv = document.getElementById('stateHistory');

                    if (data.length === 0) {
                        stateDiv.innerHTML = '<div class="text-gray-500">No state changes yet</div>';
                    } else {
                        stateDiv.innerHTML = data.map(entry => {
                            const timestamp = new Date(entry.timestamp).toLocaleTimeString();
                            const newState = entry.new_state || {};
                            return `<div class="border-b border-teal-200 pb-1 mb-1">
                                <div class="font-bold text-teal-600">[${timestamp}]</div>
                                <div class="text-gray-600">
                                    Posture: ${newState.posture || 'N/A'},
                                    Luminance: ${newState.luminance || 'N/A'},
                                    Hands: ${newState.left_hand || 'N/A'}/${newState.right_hand || 'N/A'}
                                </div>
                            </div>`;
                        }).join('');
                    }
                }
            } catch (error) {
                addLog('ERROR', `Failed to update state history: ${error.message}`);
            }
        }

        // Initialize
        addLog('INFO', 'Interface started');
        updateStats();
        getModelInfo();

        // Periodic updates
        setInterval(updateStats, 2000);  // Update stats every 2 seconds
        setInterval(updateUptime, 1000); // Update uptime every second
        setInterval(() => {
            if (currentTab === 'embodied') {
                updateEmbodiedAgentData();
                updateVoiceSystemStatus();
            }
        }, 3000); // Update tab-specific data every 3 seconds
    </script>
</body>
</html>